// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NMLPackage.proto

#ifndef PROTOBUF_NMLPackage_2eproto__INCLUDED
#define PROTOBUF_NMLPackage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace NMLPackage {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_NMLPackage_2eproto();
void protobuf_AssignDesc_NMLPackage_2eproto();
void protobuf_ShutdownFile_NMLPackage_2eproto();

class Vector3;
class ColorRGBA;
class Bounds3;
class Matrix4;
class Sampler;
class Texture;
class ColorOrTexture;
class Material;
class Submesh;
class Mesh;
class MeshInstance;
class SubmeshOp;
class SubmeshOpList;
class MeshOp;
class Model;
class ModelLODTreeNode;
class ModelLODTree;

enum Sampler_Filter {
  Sampler_Filter_NEAREST = 1,
  Sampler_Filter_BILINEAR = 2,
  Sampler_Filter_TRILINEAR = 3
};
bool Sampler_Filter_IsValid(int value);
const Sampler_Filter Sampler_Filter_Filter_MIN = Sampler_Filter_NEAREST;
const Sampler_Filter Sampler_Filter_Filter_MAX = Sampler_Filter_TRILINEAR;
const int Sampler_Filter_Filter_ARRAYSIZE = Sampler_Filter_Filter_MAX + 1;

enum Sampler_WrapMode {
  Sampler_WrapMode_CLAMP = 1,
  Sampler_WrapMode_REPEAT = 2,
  Sampler_WrapMode_MIRROR = 3
};
bool Sampler_WrapMode_IsValid(int value);
const Sampler_WrapMode Sampler_WrapMode_WrapMode_MIN = Sampler_WrapMode_CLAMP;
const Sampler_WrapMode Sampler_WrapMode_WrapMode_MAX = Sampler_WrapMode_MIRROR;
const int Sampler_WrapMode_WrapMode_ARRAYSIZE = Sampler_WrapMode_WrapMode_MAX + 1;

enum Texture_Format {
  Texture_Format_JPEG = -2,
  Texture_Format_PNG = -1,
  Texture_Format_LUMINANCE8 = 1,
  Texture_Format_RGB8 = 2,
  Texture_Format_RGBA8 = 3,
  Texture_Format_ETC1 = 4,
  Texture_Format_PVRTC = 5
};
bool Texture_Format_IsValid(int value);
const Texture_Format Texture_Format_Format_MIN = Texture_Format_JPEG;
const Texture_Format Texture_Format_Format_MAX = Texture_Format_PVRTC;
const int Texture_Format_Format_ARRAYSIZE = Texture_Format_Format_MAX + 1;

enum ColorOrTexture_Type {
  ColorOrTexture_Type_COLOR = 1,
  ColorOrTexture_Type_TEXTURE = 2
};
bool ColorOrTexture_Type_IsValid(int value);
const ColorOrTexture_Type ColorOrTexture_Type_Type_MIN = ColorOrTexture_Type_COLOR;
const ColorOrTexture_Type ColorOrTexture_Type_Type_MAX = ColorOrTexture_Type_TEXTURE;
const int ColorOrTexture_Type_Type_ARRAYSIZE = ColorOrTexture_Type_Type_MAX + 1;

enum Material_Type {
  Material_Type_CONSTANT = 1,
  Material_Type_LAMBERT = 2
};
bool Material_Type_IsValid(int value);
const Material_Type Material_Type_Type_MIN = Material_Type_CONSTANT;
const Material_Type Material_Type_Type_MAX = Material_Type_LAMBERT;
const int Material_Type_Type_ARRAYSIZE = Material_Type_Type_MAX + 1;

enum Material_Culling {
  Material_Culling_NONE = 1,
  Material_Culling_FRONT = 2,
  Material_Culling_BACK = 3
};
bool Material_Culling_IsValid(int value);
const Material_Culling Material_Culling_Culling_MIN = Material_Culling_NONE;
const Material_Culling Material_Culling_Culling_MAX = Material_Culling_BACK;
const int Material_Culling_Culling_ARRAYSIZE = Material_Culling_Culling_MAX + 1;

enum Submesh_Type {
  Submesh_Type_POINTS = 1,
  Submesh_Type_LINES = 2,
  Submesh_Type_LINE_STRIPS = 3,
  Submesh_Type_TRIANGLES = 4,
  Submesh_Type_TRIANGLE_STRIPS = 5,
  Submesh_Type_TRIANGLE_FANS = 6
};
bool Submesh_Type_IsValid(int value);
const Submesh_Type Submesh_Type_Type_MIN = Submesh_Type_POINTS;
const Submesh_Type Submesh_Type_Type_MAX = Submesh_Type_TRIANGLE_FANS;
const int Submesh_Type_Type_ARRAYSIZE = Submesh_Type_Type_MAX + 1;

// ===================================================================

class Vector3 : public ::google::protobuf::MessageLite {
 public:
  Vector3();
  virtual ~Vector3();
  
  Vector3(const Vector3& from);
  
  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Vector3& default_instance();
  
  void Swap(Vector3* other);
  
  // implements Message ----------------------------------------------
  
  Vector3* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // @@protoc_insertion_point(class_scope:NMLPackage.Vector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  
  float x_;
  float y_;
  float z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static Vector3* default_instance_;
};
// -------------------------------------------------------------------

class ColorRGBA : public ::google::protobuf::MessageLite {
 public:
  ColorRGBA();
  virtual ~ColorRGBA();
  
  ColorRGBA(const ColorRGBA& from);
  
  inline ColorRGBA& operator=(const ColorRGBA& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ColorRGBA& default_instance();
  
  void Swap(ColorRGBA* other);
  
  // implements Message ----------------------------------------------
  
  ColorRGBA* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ColorRGBA& from);
  void MergeFrom(const ColorRGBA& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float r = 1;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 1;
  inline float r() const;
  inline void set_r(float value);
  
  // required float g = 2;
  inline bool has_g() const;
  inline void clear_g();
  static const int kGFieldNumber = 2;
  inline float g() const;
  inline void set_g(float value);
  
  // required float b = 3;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 3;
  inline float b() const;
  inline void set_b(float value);
  
  // required float a = 4;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 4;
  inline float a() const;
  inline void set_a(float value);
  
  // @@protoc_insertion_point(class_scope:NMLPackage.ColorRGBA)
 private:
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_g();
  inline void clear_has_g();
  inline void set_has_b();
  inline void clear_has_b();
  inline void set_has_a();
  inline void clear_has_a();
  
  float r_;
  float g_;
  float b_;
  float a_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static ColorRGBA* default_instance_;
};
// -------------------------------------------------------------------

class Bounds3 : public ::google::protobuf::MessageLite {
 public:
  Bounds3();
  virtual ~Bounds3();
  
  Bounds3(const Bounds3& from);
  
  inline Bounds3& operator=(const Bounds3& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Bounds3& default_instance();
  
  void Swap(Bounds3* other);
  
  // implements Message ----------------------------------------------
  
  Bounds3* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Bounds3& from);
  void MergeFrom(const Bounds3& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .NMLPackage.Vector3 min = 1;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 1;
  inline const ::NMLPackage::Vector3& min() const;
  inline ::NMLPackage::Vector3* mutable_min();
  inline ::NMLPackage::Vector3* release_min();
  
  // required .NMLPackage.Vector3 max = 2;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 2;
  inline const ::NMLPackage::Vector3& max() const;
  inline ::NMLPackage::Vector3* mutable_max();
  inline ::NMLPackage::Vector3* release_max();
  
  // @@protoc_insertion_point(class_scope:NMLPackage.Bounds3)
 private:
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();
  
  ::NMLPackage::Vector3* min_;
  ::NMLPackage::Vector3* max_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static Bounds3* default_instance_;
};
// -------------------------------------------------------------------

class Matrix4 : public ::google::protobuf::MessageLite {
 public:
  Matrix4();
  virtual ~Matrix4();
  
  Matrix4(const Matrix4& from);
  
  inline Matrix4& operator=(const Matrix4& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Matrix4& default_instance();
  
  void Swap(Matrix4* other);
  
  // implements Message ----------------------------------------------
  
  Matrix4* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Matrix4& from);
  void MergeFrom(const Matrix4& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float m00 = 1;
  inline bool has_m00() const;
  inline void clear_m00();
  static const int kM00FieldNumber = 1;
  inline float m00() const;
  inline void set_m00(float value);
  
  // required float m01 = 2;
  inline bool has_m01() const;
  inline void clear_m01();
  static const int kM01FieldNumber = 2;
  inline float m01() const;
  inline void set_m01(float value);
  
  // required float m02 = 3;
  inline bool has_m02() const;
  inline void clear_m02();
  static const int kM02FieldNumber = 3;
  inline float m02() const;
  inline void set_m02(float value);
  
  // required float m03 = 4;
  inline bool has_m03() const;
  inline void clear_m03();
  static const int kM03FieldNumber = 4;
  inline float m03() const;
  inline void set_m03(float value);
  
  // required float m10 = 5;
  inline bool has_m10() const;
  inline void clear_m10();
  static const int kM10FieldNumber = 5;
  inline float m10() const;
  inline void set_m10(float value);
  
  // required float m11 = 6;
  inline bool has_m11() const;
  inline void clear_m11();
  static const int kM11FieldNumber = 6;
  inline float m11() const;
  inline void set_m11(float value);
  
  // required float m12 = 7;
  inline bool has_m12() const;
  inline void clear_m12();
  static const int kM12FieldNumber = 7;
  inline float m12() const;
  inline void set_m12(float value);
  
  // required float m13 = 8;
  inline bool has_m13() const;
  inline void clear_m13();
  static const int kM13FieldNumber = 8;
  inline float m13() const;
  inline void set_m13(float value);
  
  // required float m20 = 9;
  inline bool has_m20() const;
  inline void clear_m20();
  static const int kM20FieldNumber = 9;
  inline float m20() const;
  inline void set_m20(float value);
  
  // required float m21 = 10;
  inline bool has_m21() const;
  inline void clear_m21();
  static const int kM21FieldNumber = 10;
  inline float m21() const;
  inline void set_m21(float value);
  
  // required float m22 = 11;
  inline bool has_m22() const;
  inline void clear_m22();
  static const int kM22FieldNumber = 11;
  inline float m22() const;
  inline void set_m22(float value);
  
  // required float m23 = 12;
  inline bool has_m23() const;
  inline void clear_m23();
  static const int kM23FieldNumber = 12;
  inline float m23() const;
  inline void set_m23(float value);
  
  // required float m30 = 13;
  inline bool has_m30() const;
  inline void clear_m30();
  static const int kM30FieldNumber = 13;
  inline float m30() const;
  inline void set_m30(float value);
  
  // required float m31 = 14;
  inline bool has_m31() const;
  inline void clear_m31();
  static const int kM31FieldNumber = 14;
  inline float m31() const;
  inline void set_m31(float value);
  
  // required float m32 = 15;
  inline bool has_m32() const;
  inline void clear_m32();
  static const int kM32FieldNumber = 15;
  inline float m32() const;
  inline void set_m32(float value);
  
  // required float m33 = 16;
  inline bool has_m33() const;
  inline void clear_m33();
  static const int kM33FieldNumber = 16;
  inline float m33() const;
  inline void set_m33(float value);
  
  // @@protoc_insertion_point(class_scope:NMLPackage.Matrix4)
 private:
  inline void set_has_m00();
  inline void clear_has_m00();
  inline void set_has_m01();
  inline void clear_has_m01();
  inline void set_has_m02();
  inline void clear_has_m02();
  inline void set_has_m03();
  inline void clear_has_m03();
  inline void set_has_m10();
  inline void clear_has_m10();
  inline void set_has_m11();
  inline void clear_has_m11();
  inline void set_has_m12();
  inline void clear_has_m12();
  inline void set_has_m13();
  inline void clear_has_m13();
  inline void set_has_m20();
  inline void clear_has_m20();
  inline void set_has_m21();
  inline void clear_has_m21();
  inline void set_has_m22();
  inline void clear_has_m22();
  inline void set_has_m23();
  inline void clear_has_m23();
  inline void set_has_m30();
  inline void clear_has_m30();
  inline void set_has_m31();
  inline void clear_has_m31();
  inline void set_has_m32();
  inline void clear_has_m32();
  inline void set_has_m33();
  inline void clear_has_m33();
  
  float m00_;
  float m01_;
  float m02_;
  float m03_;
  float m10_;
  float m11_;
  float m12_;
  float m13_;
  float m20_;
  float m21_;
  float m22_;
  float m23_;
  float m30_;
  float m31_;
  float m32_;
  float m33_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static Matrix4* default_instance_;
};
// -------------------------------------------------------------------

class Sampler : public ::google::protobuf::MessageLite {
 public:
  Sampler();
  virtual ~Sampler();
  
  Sampler(const Sampler& from);
  
  inline Sampler& operator=(const Sampler& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Sampler& default_instance();
  
  void Swap(Sampler* other);
  
  // implements Message ----------------------------------------------
  
  Sampler* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Sampler& from);
  void MergeFrom(const Sampler& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef Sampler_Filter Filter;
  static const Filter NEAREST = Sampler_Filter_NEAREST;
  static const Filter BILINEAR = Sampler_Filter_BILINEAR;
  static const Filter TRILINEAR = Sampler_Filter_TRILINEAR;
  static inline bool Filter_IsValid(int value) {
    return Sampler_Filter_IsValid(value);
  }
  static const Filter Filter_MIN =
    Sampler_Filter_Filter_MIN;
  static const Filter Filter_MAX =
    Sampler_Filter_Filter_MAX;
  static const int Filter_ARRAYSIZE =
    Sampler_Filter_Filter_ARRAYSIZE;
  
  typedef Sampler_WrapMode WrapMode;
  static const WrapMode CLAMP = Sampler_WrapMode_CLAMP;
  static const WrapMode REPEAT = Sampler_WrapMode_REPEAT;
  static const WrapMode MIRROR = Sampler_WrapMode_MIRROR;
  static inline bool WrapMode_IsValid(int value) {
    return Sampler_WrapMode_IsValid(value);
  }
  static const WrapMode WrapMode_MIN =
    Sampler_WrapMode_WrapMode_MIN;
  static const WrapMode WrapMode_MAX =
    Sampler_WrapMode_WrapMode_MAX;
  static const int WrapMode_ARRAYSIZE =
    Sampler_WrapMode_WrapMode_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional .NMLPackage.Sampler.Filter filter = 1;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 1;
  inline ::NMLPackage::Sampler_Filter filter() const;
  inline void set_filter(::NMLPackage::Sampler_Filter value);
  
  // optional .NMLPackage.Sampler.WrapMode wrap_s = 2;
  inline bool has_wrap_s() const;
  inline void clear_wrap_s();
  static const int kWrapSFieldNumber = 2;
  inline ::NMLPackage::Sampler_WrapMode wrap_s() const;
  inline void set_wrap_s(::NMLPackage::Sampler_WrapMode value);
  
  // optional .NMLPackage.Sampler.WrapMode wrap_t = 3;
  inline bool has_wrap_t() const;
  inline void clear_wrap_t();
  static const int kWrapTFieldNumber = 3;
  inline ::NMLPackage::Sampler_WrapMode wrap_t() const;
  inline void set_wrap_t(::NMLPackage::Sampler_WrapMode value);
  
  // @@protoc_insertion_point(class_scope:NMLPackage.Sampler)
 private:
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_wrap_s();
  inline void clear_has_wrap_s();
  inline void set_has_wrap_t();
  inline void clear_has_wrap_t();
  
  int filter_;
  int wrap_s_;
  int wrap_t_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static Sampler* default_instance_;
};
// -------------------------------------------------------------------

class Texture : public ::google::protobuf::MessageLite {
 public:
  Texture();
  virtual ~Texture();
  
  Texture(const Texture& from);
  
  inline Texture& operator=(const Texture& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Texture& default_instance();
  
  void Swap(Texture* other);
  
  // implements Message ----------------------------------------------
  
  Texture* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Texture& from);
  void MergeFrom(const Texture& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef Texture_Format Format;
  static const Format JPEG = Texture_Format_JPEG;
  static const Format PNG = Texture_Format_PNG;
  static const Format LUMINANCE8 = Texture_Format_LUMINANCE8;
  static const Format RGB8 = Texture_Format_RGB8;
  static const Format RGBA8 = Texture_Format_RGBA8;
  static const Format ETC1 = Texture_Format_ETC1;
  static const Format PVRTC = Texture_Format_PVRTC;
  static inline bool Format_IsValid(int value) {
    return Texture_Format_IsValid(value);
  }
  static const Format Format_MIN =
    Texture_Format_Format_MIN;
  static const Format Format_MAX =
    Texture_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    Texture_Format_Format_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required .NMLPackage.Texture.Format format = 2;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 2;
  inline ::NMLPackage::Texture_Format format() const;
  inline void set_format(::NMLPackage::Texture_Format value);
  
  // required int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // required int32 height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // required .NMLPackage.Sampler sampler = 5;
  inline bool has_sampler() const;
  inline void clear_sampler();
  static const int kSamplerFieldNumber = 5;
  inline const ::NMLPackage::Sampler& sampler() const;
  inline ::NMLPackage::Sampler* mutable_sampler();
  inline ::NMLPackage::Sampler* release_sampler();
  
  // repeated bytes mipmaps = 6;
  inline int mipmaps_size() const;
  inline void clear_mipmaps();
  static const int kMipmapsFieldNumber = 6;
  inline const ::std::string& mipmaps(int index) const;
  inline ::std::string* mutable_mipmaps(int index);
  inline void set_mipmaps(int index, const ::std::string& value);
  inline void set_mipmaps(int index, const char* value);
  inline void set_mipmaps(int index, const void* value, size_t size);
  inline ::std::string* add_mipmaps();
  inline void add_mipmaps(const ::std::string& value);
  inline void add_mipmaps(const char* value);
  inline void add_mipmaps(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mipmaps() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mipmaps();
  
  // @@protoc_insertion_point(class_scope:NMLPackage.Texture)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_sampler();
  inline void clear_has_sampler();
  
  ::std::string* id_;
  int format_;
  ::google::protobuf::int32 width_;
  ::NMLPackage::Sampler* sampler_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mipmaps_;
  ::google::protobuf::int32 height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static Texture* default_instance_;
};
// -------------------------------------------------------------------

class ColorOrTexture : public ::google::protobuf::MessageLite {
 public:
  ColorOrTexture();
  virtual ~ColorOrTexture();
  
  ColorOrTexture(const ColorOrTexture& from);
  
  inline ColorOrTexture& operator=(const ColorOrTexture& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ColorOrTexture& default_instance();
  
  void Swap(ColorOrTexture* other);
  
  // implements Message ----------------------------------------------
  
  ColorOrTexture* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ColorOrTexture& from);
  void MergeFrom(const ColorOrTexture& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ColorOrTexture_Type Type;
  static const Type COLOR = ColorOrTexture_Type_COLOR;
  static const Type TEXTURE = ColorOrTexture_Type_TEXTURE;
  static inline bool Type_IsValid(int value) {
    return ColorOrTexture_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ColorOrTexture_Type_Type_MIN;
  static const Type Type_MAX =
    ColorOrTexture_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ColorOrTexture_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .NMLPackage.ColorOrTexture.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::NMLPackage::ColorOrTexture_Type type() const;
  inline void set_type(::NMLPackage::ColorOrTexture_Type value);
  
  // optional .NMLPackage.ColorRGBA color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline const ::NMLPackage::ColorRGBA& color() const;
  inline ::NMLPackage::ColorRGBA* mutable_color();
  inline ::NMLPackage::ColorRGBA* release_color();
  
  // optional string texture_id = 3;
  inline bool has_texture_id() const;
  inline void clear_texture_id();
  static const int kTextureIdFieldNumber = 3;
  inline const ::std::string& texture_id() const;
  inline void set_texture_id(const ::std::string& value);
  inline void set_texture_id(const char* value);
  inline void set_texture_id(const char* value, size_t size);
  inline ::std::string* mutable_texture_id();
  inline ::std::string* release_texture_id();
  
  // @@protoc_insertion_point(class_scope:NMLPackage.ColorOrTexture)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_texture_id();
  inline void clear_has_texture_id();
  
  ::NMLPackage::ColorRGBA* color_;
  ::std::string* texture_id_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static ColorOrTexture* default_instance_;
};
// -------------------------------------------------------------------

class Material : public ::google::protobuf::MessageLite {
 public:
  Material();
  virtual ~Material();
  
  Material(const Material& from);
  
  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Material& default_instance();
  
  void Swap(Material* other);
  
  // implements Message ----------------------------------------------
  
  Material* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef Material_Type Type;
  static const Type CONSTANT = Material_Type_CONSTANT;
  static const Type LAMBERT = Material_Type_LAMBERT;
  static inline bool Type_IsValid(int value) {
    return Material_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Material_Type_Type_MIN;
  static const Type Type_MAX =
    Material_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Material_Type_Type_ARRAYSIZE;
  
  typedef Material_Culling Culling;
  static const Culling NONE = Material_Culling_NONE;
  static const Culling FRONT = Material_Culling_FRONT;
  static const Culling BACK = Material_Culling_BACK;
  static inline bool Culling_IsValid(int value) {
    return Material_Culling_IsValid(value);
  }
  static const Culling Culling_MIN =
    Material_Culling_Culling_MIN;
  static const Culling Culling_MAX =
    Material_Culling_Culling_MAX;
  static const int Culling_ARRAYSIZE =
    Material_Culling_Culling_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required .NMLPackage.Material.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::NMLPackage::Material_Type type() const;
  inline void set_type(::NMLPackage::Material_Type value);
  
  // required .NMLPackage.Material.Culling culling = 3;
  inline bool has_culling() const;
  inline void clear_culling();
  static const int kCullingFieldNumber = 3;
  inline ::NMLPackage::Material_Culling culling() const;
  inline void set_culling(::NMLPackage::Material_Culling value);
  
  // optional .NMLPackage.ColorOrTexture emission = 4;
  inline bool has_emission() const;
  inline void clear_emission();
  static const int kEmissionFieldNumber = 4;
  inline const ::NMLPackage::ColorOrTexture& emission() const;
  inline ::NMLPackage::ColorOrTexture* mutable_emission();
  inline ::NMLPackage::ColorOrTexture* release_emission();
  
  // optional .NMLPackage.ColorOrTexture ambient = 5;
  inline bool has_ambient() const;
  inline void clear_ambient();
  static const int kAmbientFieldNumber = 5;
  inline const ::NMLPackage::ColorOrTexture& ambient() const;
  inline ::NMLPackage::ColorOrTexture* mutable_ambient();
  inline ::NMLPackage::ColorOrTexture* release_ambient();
  
  // optional .NMLPackage.ColorOrTexture diffuse = 6;
  inline bool has_diffuse() const;
  inline void clear_diffuse();
  static const int kDiffuseFieldNumber = 6;
  inline const ::NMLPackage::ColorOrTexture& diffuse() const;
  inline ::NMLPackage::ColorOrTexture* mutable_diffuse();
  inline ::NMLPackage::ColorOrTexture* release_diffuse();
  
  // optional bool translucent = 7;
  inline bool has_translucent() const;
  inline void clear_translucent();
  static const int kTranslucentFieldNumber = 7;
  inline bool translucent() const;
  inline void set_translucent(bool value);
  
  // @@protoc_insertion_point(class_scope:NMLPackage.Material)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_culling();
  inline void clear_has_culling();
  inline void set_has_emission();
  inline void clear_has_emission();
  inline void set_has_ambient();
  inline void clear_has_ambient();
  inline void set_has_diffuse();
  inline void clear_has_diffuse();
  inline void set_has_translucent();
  inline void clear_has_translucent();
  
  ::std::string* id_;
  int type_;
  int culling_;
  ::NMLPackage::ColorOrTexture* emission_;
  ::NMLPackage::ColorOrTexture* ambient_;
  ::NMLPackage::ColorOrTexture* diffuse_;
  bool translucent_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static Material* default_instance_;
};
// -------------------------------------------------------------------

class Submesh : public ::google::protobuf::MessageLite {
 public:
  Submesh();
  virtual ~Submesh();
  
  Submesh(const Submesh& from);
  
  inline Submesh& operator=(const Submesh& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Submesh& default_instance();
  
  void Swap(Submesh* other);
  
  // implements Message ----------------------------------------------
  
  Submesh* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Submesh& from);
  void MergeFrom(const Submesh& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef Submesh_Type Type;
  static const Type POINTS = Submesh_Type_POINTS;
  static const Type LINES = Submesh_Type_LINES;
  static const Type LINE_STRIPS = Submesh_Type_LINE_STRIPS;
  static const Type TRIANGLES = Submesh_Type_TRIANGLES;
  static const Type TRIANGLE_STRIPS = Submesh_Type_TRIANGLE_STRIPS;
  static const Type TRIANGLE_FANS = Submesh_Type_TRIANGLE_FANS;
  static inline bool Type_IsValid(int value) {
    return Submesh_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Submesh_Type_Type_MIN;
  static const Type Type_MAX =
    Submesh_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Submesh_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .NMLPackage.Submesh.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::NMLPackage::Submesh_Type type() const;
  inline void set_type(::NMLPackage::Submesh_Type value);
  
  // required string material_id = 2;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 2;
  inline const ::std::string& material_id() const;
  inline void set_material_id(const ::std::string& value);
  inline void set_material_id(const char* value);
  inline void set_material_id(const char* value, size_t size);
  inline ::std::string* mutable_material_id();
  inline ::std::string* release_material_id();
  
  // repeated int32 vertex_counts = 3;
  inline int vertex_counts_size() const;
  inline void clear_vertex_counts();
  static const int kVertexCountsFieldNumber = 3;
  inline ::google::protobuf::int32 vertex_counts(int index) const;
  inline void set_vertex_counts(int index, ::google::protobuf::int32 value);
  inline void add_vertex_counts(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vertex_counts() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vertex_counts();
  
  // required bytes positions = 4;
  inline bool has_positions() const;
  inline void clear_positions();
  static const int kPositionsFieldNumber = 4;
  inline const ::std::string& positions() const;
  inline void set_positions(const ::std::string& value);
  inline void set_positions(const char* value);
  inline void set_positions(const void* value, size_t size);
  inline ::std::string* mutable_positions();
  inline ::std::string* release_positions();
  
  // optional bytes normals = 5;
  inline bool has_normals() const;
  inline void clear_normals();
  static const int kNormalsFieldNumber = 5;
  inline const ::std::string& normals() const;
  inline void set_normals(const ::std::string& value);
  inline void set_normals(const char* value);
  inline void set_normals(const void* value, size_t size);
  inline ::std::string* mutable_normals();
  inline ::std::string* release_normals();
  
  // optional bytes uvs = 6;
  inline bool has_uvs() const;
  inline void clear_uvs();
  static const int kUvsFieldNumber = 6;
  inline const ::std::string& uvs() const;
  inline void set_uvs(const ::std::string& value);
  inline void set_uvs(const char* value);
  inline void set_uvs(const void* value, size_t size);
  inline ::std::string* mutable_uvs();
  inline ::std::string* release_uvs();
  
  // optional bytes colors = 7;
  inline bool has_colors() const;
  inline void clear_colors();
  static const int kColorsFieldNumber = 7;
  inline const ::std::string& colors() const;
  inline void set_colors(const ::std::string& value);
  inline void set_colors(const char* value);
  inline void set_colors(const void* value, size_t size);
  inline ::std::string* mutable_colors();
  inline ::std::string* release_colors();
  
  // repeated int64 vertex_ids = 8;
  inline int vertex_ids_size() const;
  inline void clear_vertex_ids();
  static const int kVertexIdsFieldNumber = 8;
  inline ::google::protobuf::int64 vertex_ids(int index) const;
  inline void set_vertex_ids(int index, ::google::protobuf::int64 value);
  inline void add_vertex_ids(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      vertex_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_vertex_ids();
  
  // @@protoc_insertion_point(class_scope:NMLPackage.Submesh)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_material_id();
  inline void clear_has_material_id();
  inline void set_has_positions();
  inline void clear_has_positions();
  inline void set_has_normals();
  inline void clear_has_normals();
  inline void set_has_uvs();
  inline void clear_has_uvs();
  inline void set_has_colors();
  inline void clear_has_colors();
  
  ::std::string* material_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vertex_counts_;
  ::std::string* positions_;
  ::std::string* normals_;
  ::std::string* uvs_;
  ::std::string* colors_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > vertex_ids_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static Submesh* default_instance_;
};
// -------------------------------------------------------------------

class Mesh : public ::google::protobuf::MessageLite {
 public:
  Mesh();
  virtual ~Mesh();
  
  Mesh(const Mesh& from);
  
  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Mesh& default_instance();
  
  void Swap(Mesh* other);
  
  // implements Message ----------------------------------------------
  
  Mesh* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required .NMLPackage.Bounds3 bounds = 2;
  inline bool has_bounds() const;
  inline void clear_bounds();
  static const int kBoundsFieldNumber = 2;
  inline const ::NMLPackage::Bounds3& bounds() const;
  inline ::NMLPackage::Bounds3* mutable_bounds();
  inline ::NMLPackage::Bounds3* release_bounds();
  
  // repeated .NMLPackage.Submesh submeshes = 3;
  inline int submeshes_size() const;
  inline void clear_submeshes();
  static const int kSubmeshesFieldNumber = 3;
  inline const ::NMLPackage::Submesh& submeshes(int index) const;
  inline ::NMLPackage::Submesh* mutable_submeshes(int index);
  inline ::NMLPackage::Submesh* add_submeshes();
  inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::Submesh >&
      submeshes() const;
  inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::Submesh >*
      mutable_submeshes();
  
  // @@protoc_insertion_point(class_scope:NMLPackage.Mesh)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_bounds();
  inline void clear_has_bounds();
  
  ::std::string* id_;
  ::NMLPackage::Bounds3* bounds_;
  ::google::protobuf::RepeatedPtrField< ::NMLPackage::Submesh > submeshes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static Mesh* default_instance_;
};
// -------------------------------------------------------------------

class MeshInstance : public ::google::protobuf::MessageLite {
 public:
  MeshInstance();
  virtual ~MeshInstance();
  
  MeshInstance(const MeshInstance& from);
  
  inline MeshInstance& operator=(const MeshInstance& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const MeshInstance& default_instance();
  
  void Swap(MeshInstance* other);
  
  // implements Message ----------------------------------------------
  
  MeshInstance* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MeshInstance& from);
  void MergeFrom(const MeshInstance& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string mesh_id = 1;
  inline bool has_mesh_id() const;
  inline void clear_mesh_id();
  static const int kMeshIdFieldNumber = 1;
  inline const ::std::string& mesh_id() const;
  inline void set_mesh_id(const ::std::string& value);
  inline void set_mesh_id(const char* value);
  inline void set_mesh_id(const char* value, size_t size);
  inline ::std::string* mutable_mesh_id();
  inline ::std::string* release_mesh_id();
  
  // repeated .NMLPackage.Material materials = 2;
  inline int materials_size() const;
  inline void clear_materials();
  static const int kMaterialsFieldNumber = 2;
  inline const ::NMLPackage::Material& materials(int index) const;
  inline ::NMLPackage::Material* mutable_materials(int index);
  inline ::NMLPackage::Material* add_materials();
  inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::Material >&
      materials() const;
  inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::Material >*
      mutable_materials();
  
  // optional .NMLPackage.Matrix4 transform = 3;
  inline bool has_transform() const;
  inline void clear_transform();
  static const int kTransformFieldNumber = 3;
  inline const ::NMLPackage::Matrix4& transform() const;
  inline ::NMLPackage::Matrix4* mutable_transform();
  inline ::NMLPackage::Matrix4* release_transform();
  
  // @@protoc_insertion_point(class_scope:NMLPackage.MeshInstance)
 private:
  inline void set_has_mesh_id();
  inline void clear_has_mesh_id();
  inline void set_has_transform();
  inline void clear_has_transform();
  
  ::std::string* mesh_id_;
  ::google::protobuf::RepeatedPtrField< ::NMLPackage::Material > materials_;
  ::NMLPackage::Matrix4* transform_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static MeshInstance* default_instance_;
};
// -------------------------------------------------------------------

class SubmeshOp : public ::google::protobuf::MessageLite {
 public:
  SubmeshOp();
  virtual ~SubmeshOp();
  
  SubmeshOp(const SubmeshOp& from);
  
  inline SubmeshOp& operator=(const SubmeshOp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SubmeshOp& default_instance();
  
  void Swap(SubmeshOp* other);
  
  // implements Message ----------------------------------------------
  
  SubmeshOp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SubmeshOp& from);
  void MergeFrom(const SubmeshOp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 submesh_idx = 1;
  inline bool has_submesh_idx() const;
  inline void clear_submesh_idx();
  static const int kSubmeshIdxFieldNumber = 1;
  inline ::google::protobuf::int32 submesh_idx() const;
  inline void set_submesh_idx(::google::protobuf::int32 value);
  
  // required int32 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);
  
  // required int32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // required float tex_u_scale = 4;
  inline bool has_tex_u_scale() const;
  inline void clear_tex_u_scale();
  static const int kTexUScaleFieldNumber = 4;
  inline float tex_u_scale() const;
  inline void set_tex_u_scale(float value);
  
  // required float tex_v_scale = 5;
  inline bool has_tex_v_scale() const;
  inline void clear_tex_v_scale();
  static const int kTexVScaleFieldNumber = 5;
  inline float tex_v_scale() const;
  inline void set_tex_v_scale(float value);
  
  // required float tex_u_trans = 6;
  inline bool has_tex_u_trans() const;
  inline void clear_tex_u_trans();
  static const int kTexUTransFieldNumber = 6;
  inline float tex_u_trans() const;
  inline void set_tex_u_trans(float value);
  
  // required float tex_v_trans = 7;
  inline bool has_tex_v_trans() const;
  inline void clear_tex_v_trans();
  static const int kTexVTransFieldNumber = 7;
  inline float tex_v_trans() const;
  inline void set_tex_v_trans(float value);
  
  // @@protoc_insertion_point(class_scope:NMLPackage.SubmeshOp)
 private:
  inline void set_has_submesh_idx();
  inline void clear_has_submesh_idx();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_tex_u_scale();
  inline void clear_has_tex_u_scale();
  inline void set_has_tex_v_scale();
  inline void clear_has_tex_v_scale();
  inline void set_has_tex_u_trans();
  inline void clear_has_tex_u_trans();
  inline void set_has_tex_v_trans();
  inline void clear_has_tex_v_trans();
  
  ::google::protobuf::int32 submesh_idx_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 count_;
  float tex_u_scale_;
  float tex_v_scale_;
  float tex_u_trans_;
  float tex_v_trans_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static SubmeshOp* default_instance_;
};
// -------------------------------------------------------------------

class SubmeshOpList : public ::google::protobuf::MessageLite {
 public:
  SubmeshOpList();
  virtual ~SubmeshOpList();
  
  SubmeshOpList(const SubmeshOpList& from);
  
  inline SubmeshOpList& operator=(const SubmeshOpList& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SubmeshOpList& default_instance();
  
  void Swap(SubmeshOpList* other);
  
  // implements Message ----------------------------------------------
  
  SubmeshOpList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SubmeshOpList& from);
  void MergeFrom(const SubmeshOpList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .NMLPackage.Submesh.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::NMLPackage::Submesh_Type type() const;
  inline void set_type(::NMLPackage::Submesh_Type value);
  
  // required string material_id = 2;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 2;
  inline const ::std::string& material_id() const;
  inline void set_material_id(const ::std::string& value);
  inline void set_material_id(const char* value);
  inline void set_material_id(const char* value, size_t size);
  inline ::std::string* mutable_material_id();
  inline ::std::string* release_material_id();
  
  // repeated .NMLPackage.SubmeshOp submesh_ops = 3;
  inline int submesh_ops_size() const;
  inline void clear_submesh_ops();
  static const int kSubmeshOpsFieldNumber = 3;
  inline const ::NMLPackage::SubmeshOp& submesh_ops(int index) const;
  inline ::NMLPackage::SubmeshOp* mutable_submesh_ops(int index);
  inline ::NMLPackage::SubmeshOp* add_submesh_ops();
  inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::SubmeshOp >&
      submesh_ops() const;
  inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::SubmeshOp >*
      mutable_submesh_ops();
  
  // @@protoc_insertion_point(class_scope:NMLPackage.SubmeshOpList)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_material_id();
  inline void clear_has_material_id();
  
  ::std::string* material_id_;
  ::google::protobuf::RepeatedPtrField< ::NMLPackage::SubmeshOp > submesh_ops_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static SubmeshOpList* default_instance_;
};
// -------------------------------------------------------------------

class MeshOp : public ::google::protobuf::MessageLite {
 public:
  MeshOp();
  virtual ~MeshOp();
  
  MeshOp(const MeshOp& from);
  
  inline MeshOp& operator=(const MeshOp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const MeshOp& default_instance();
  
  void Swap(MeshOp* other);
  
  // implements Message ----------------------------------------------
  
  MeshOp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MeshOp& from);
  void MergeFrom(const MeshOp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required .NMLPackage.Bounds3 bounds = 2;
  inline bool has_bounds() const;
  inline void clear_bounds();
  static const int kBoundsFieldNumber = 2;
  inline const ::NMLPackage::Bounds3& bounds() const;
  inline ::NMLPackage::Bounds3* mutable_bounds();
  inline ::NMLPackage::Bounds3* release_bounds();
  
  // repeated .NMLPackage.SubmeshOpList submesh_op_lists = 3;
  inline int submesh_op_lists_size() const;
  inline void clear_submesh_op_lists();
  static const int kSubmeshOpListsFieldNumber = 3;
  inline const ::NMLPackage::SubmeshOpList& submesh_op_lists(int index) const;
  inline ::NMLPackage::SubmeshOpList* mutable_submesh_op_lists(int index);
  inline ::NMLPackage::SubmeshOpList* add_submesh_op_lists();
  inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::SubmeshOpList >&
      submesh_op_lists() const;
  inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::SubmeshOpList >*
      mutable_submesh_op_lists();
  
  // @@protoc_insertion_point(class_scope:NMLPackage.MeshOp)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_bounds();
  inline void clear_has_bounds();
  
  ::std::string* id_;
  ::NMLPackage::Bounds3* bounds_;
  ::google::protobuf::RepeatedPtrField< ::NMLPackage::SubmeshOpList > submesh_op_lists_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static MeshOp* default_instance_;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::MessageLite {
 public:
  Model();
  virtual ~Model();
  
  Model(const Model& from);
  
  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Model& default_instance();
  
  void Swap(Model* other);
  
  // implements Message ----------------------------------------------
  
  Model* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // repeated .NMLPackage.MeshInstance mesh_instances = 2;
  inline int mesh_instances_size() const;
  inline void clear_mesh_instances();
  static const int kMeshInstancesFieldNumber = 2;
  inline const ::NMLPackage::MeshInstance& mesh_instances(int index) const;
  inline ::NMLPackage::MeshInstance* mutable_mesh_instances(int index);
  inline ::NMLPackage::MeshInstance* add_mesh_instances();
  inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::MeshInstance >&
      mesh_instances() const;
  inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::MeshInstance >*
      mutable_mesh_instances();
  
  // repeated .NMLPackage.Mesh meshes = 3;
  inline int meshes_size() const;
  inline void clear_meshes();
  static const int kMeshesFieldNumber = 3;
  inline const ::NMLPackage::Mesh& meshes(int index) const;
  inline ::NMLPackage::Mesh* mutable_meshes(int index);
  inline ::NMLPackage::Mesh* add_meshes();
  inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::Mesh >&
      meshes() const;
  inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::Mesh >*
      mutable_meshes();
  
  // repeated .NMLPackage.Texture textures = 4;
  inline int textures_size() const;
  inline void clear_textures();
  static const int kTexturesFieldNumber = 4;
  inline const ::NMLPackage::Texture& textures(int index) const;
  inline ::NMLPackage::Texture* mutable_textures(int index);
  inline ::NMLPackage::Texture* add_textures();
  inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::Texture >&
      textures() const;
  inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::Texture >*
      mutable_textures();
  
  // required .NMLPackage.Bounds3 bounds = 5;
  inline bool has_bounds() const;
  inline void clear_bounds();
  static const int kBoundsFieldNumber = 5;
  inline const ::NMLPackage::Bounds3& bounds() const;
  inline ::NMLPackage::Bounds3* mutable_bounds();
  inline ::NMLPackage::Bounds3* release_bounds();
  
  // required int32 mesh_footprint = 6;
  inline bool has_mesh_footprint() const;
  inline void clear_mesh_footprint();
  static const int kMeshFootprintFieldNumber = 6;
  inline ::google::protobuf::int32 mesh_footprint() const;
  inline void set_mesh_footprint(::google::protobuf::int32 value);
  
  // required int32 texture_footprint = 7;
  inline bool has_texture_footprint() const;
  inline void clear_texture_footprint();
  static const int kTextureFootprintFieldNumber = 7;
  inline ::google::protobuf::int32 texture_footprint() const;
  inline void set_texture_footprint(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:NMLPackage.Model)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_bounds();
  inline void clear_has_bounds();
  inline void set_has_mesh_footprint();
  inline void clear_has_mesh_footprint();
  inline void set_has_texture_footprint();
  inline void clear_has_texture_footprint();
  
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::NMLPackage::MeshInstance > mesh_instances_;
  ::google::protobuf::RepeatedPtrField< ::NMLPackage::Mesh > meshes_;
  ::google::protobuf::RepeatedPtrField< ::NMLPackage::Texture > textures_;
  ::NMLPackage::Bounds3* bounds_;
  ::google::protobuf::int32 mesh_footprint_;
  ::google::protobuf::int32 texture_footprint_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static Model* default_instance_;
};
// -------------------------------------------------------------------

class ModelLODTreeNode : public ::google::protobuf::MessageLite {
 public:
  ModelLODTreeNode();
  virtual ~ModelLODTreeNode();
  
  ModelLODTreeNode(const ModelLODTreeNode& from);
  
  inline ModelLODTreeNode& operator=(const ModelLODTreeNode& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ModelLODTreeNode& default_instance();
  
  void Swap(ModelLODTreeNode* other);
  
  // implements Message ----------------------------------------------
  
  ModelLODTreeNode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ModelLODTreeNode& from);
  void MergeFrom(const ModelLODTreeNode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required .NMLPackage.Bounds3 bounds = 2;
  inline bool has_bounds() const;
  inline void clear_bounds();
  static const int kBoundsFieldNumber = 2;
  inline const ::NMLPackage::Bounds3& bounds() const;
  inline ::NMLPackage::Bounds3* mutable_bounds();
  inline ::NMLPackage::Bounds3* release_bounds();
  
  // required .NMLPackage.Model model = 3;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 3;
  inline const ::NMLPackage::Model& model() const;
  inline ::NMLPackage::Model* mutable_model();
  inline ::NMLPackage::Model* release_model();
  
  // repeated int32 children_ids = 4;
  inline int children_ids_size() const;
  inline void clear_children_ids();
  static const int kChildrenIdsFieldNumber = 4;
  inline ::google::protobuf::int32 children_ids(int index) const;
  inline void set_children_ids(int index, ::google::protobuf::int32 value);
  inline void add_children_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      children_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_children_ids();
  
  // @@protoc_insertion_point(class_scope:NMLPackage.ModelLODTreeNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_bounds();
  inline void clear_has_bounds();
  inline void set_has_model();
  inline void clear_has_model();
  
  ::NMLPackage::Bounds3* bounds_;
  ::NMLPackage::Model* model_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > children_ids_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static ModelLODTreeNode* default_instance_;
};
// -------------------------------------------------------------------

class ModelLODTree : public ::google::protobuf::MessageLite {
 public:
  ModelLODTree();
  virtual ~ModelLODTree();
  
  ModelLODTree(const ModelLODTree& from);
  
  inline ModelLODTree& operator=(const ModelLODTree& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ModelLODTree& default_instance();
  
  void Swap(ModelLODTree* other);
  
  // implements Message ----------------------------------------------
  
  ModelLODTree* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ModelLODTree& from);
  void MergeFrom(const ModelLODTree& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .NMLPackage.ModelLODTreeNode nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::NMLPackage::ModelLODTreeNode& nodes(int index) const;
  inline ::NMLPackage::ModelLODTreeNode* mutable_nodes(int index);
  inline ::NMLPackage::ModelLODTreeNode* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::ModelLODTreeNode >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::ModelLODTreeNode >*
      mutable_nodes();
  
  // @@protoc_insertion_point(class_scope:NMLPackage.ModelLODTree)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::NMLPackage::ModelLODTreeNode > nodes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_NMLPackage_2eproto();
  friend void protobuf_AssignDesc_NMLPackage_2eproto();
  friend void protobuf_ShutdownFile_NMLPackage_2eproto();
  
  void InitAsDefaultInstance();
  static ModelLODTree* default_instance_;
};
// ===================================================================


// ===================================================================

// Vector3

// required float x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector3::x() const {
  return x_;
}
inline void Vector3::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector3::y() const {
  return y_;
}
inline void Vector3::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector3::z() const {
  return z_;
}
inline void Vector3::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// ColorRGBA

// required float r = 1;
inline bool ColorRGBA::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColorRGBA::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColorRGBA::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColorRGBA::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline float ColorRGBA::r() const {
  return r_;
}
inline void ColorRGBA::set_r(float value) {
  set_has_r();
  r_ = value;
}

// required float g = 2;
inline bool ColorRGBA::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColorRGBA::set_has_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColorRGBA::clear_has_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColorRGBA::clear_g() {
  g_ = 0;
  clear_has_g();
}
inline float ColorRGBA::g() const {
  return g_;
}
inline void ColorRGBA::set_g(float value) {
  set_has_g();
  g_ = value;
}

// required float b = 3;
inline bool ColorRGBA::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColorRGBA::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColorRGBA::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColorRGBA::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline float ColorRGBA::b() const {
  return b_;
}
inline void ColorRGBA::set_b(float value) {
  set_has_b();
  b_ = value;
}

// required float a = 4;
inline bool ColorRGBA::has_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColorRGBA::set_has_a() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ColorRGBA::clear_has_a() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ColorRGBA::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline float ColorRGBA::a() const {
  return a_;
}
inline void ColorRGBA::set_a(float value) {
  set_has_a();
  a_ = value;
}

// -------------------------------------------------------------------

// Bounds3

// required .NMLPackage.Vector3 min = 1;
inline bool Bounds3::has_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bounds3::set_has_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bounds3::clear_has_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bounds3::clear_min() {
  if (min_ != NULL) min_->::NMLPackage::Vector3::Clear();
  clear_has_min();
}
inline const ::NMLPackage::Vector3& Bounds3::min() const {
  return min_ != NULL ? *min_ : *default_instance_->min_;
}
inline ::NMLPackage::Vector3* Bounds3::mutable_min() {
  set_has_min();
  if (min_ == NULL) min_ = new ::NMLPackage::Vector3;
  return min_;
}
inline ::NMLPackage::Vector3* Bounds3::release_min() {
  clear_has_min();
  ::NMLPackage::Vector3* temp = min_;
  min_ = NULL;
  return temp;
}

// required .NMLPackage.Vector3 max = 2;
inline bool Bounds3::has_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bounds3::set_has_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bounds3::clear_has_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bounds3::clear_max() {
  if (max_ != NULL) max_->::NMLPackage::Vector3::Clear();
  clear_has_max();
}
inline const ::NMLPackage::Vector3& Bounds3::max() const {
  return max_ != NULL ? *max_ : *default_instance_->max_;
}
inline ::NMLPackage::Vector3* Bounds3::mutable_max() {
  set_has_max();
  if (max_ == NULL) max_ = new ::NMLPackage::Vector3;
  return max_;
}
inline ::NMLPackage::Vector3* Bounds3::release_max() {
  clear_has_max();
  ::NMLPackage::Vector3* temp = max_;
  max_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Matrix4

// required float m00 = 1;
inline bool Matrix4::has_m00() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Matrix4::set_has_m00() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Matrix4::clear_has_m00() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Matrix4::clear_m00() {
  m00_ = 0;
  clear_has_m00();
}
inline float Matrix4::m00() const {
  return m00_;
}
inline void Matrix4::set_m00(float value) {
  set_has_m00();
  m00_ = value;
}

// required float m01 = 2;
inline bool Matrix4::has_m01() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Matrix4::set_has_m01() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Matrix4::clear_has_m01() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Matrix4::clear_m01() {
  m01_ = 0;
  clear_has_m01();
}
inline float Matrix4::m01() const {
  return m01_;
}
inline void Matrix4::set_m01(float value) {
  set_has_m01();
  m01_ = value;
}

// required float m02 = 3;
inline bool Matrix4::has_m02() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Matrix4::set_has_m02() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Matrix4::clear_has_m02() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Matrix4::clear_m02() {
  m02_ = 0;
  clear_has_m02();
}
inline float Matrix4::m02() const {
  return m02_;
}
inline void Matrix4::set_m02(float value) {
  set_has_m02();
  m02_ = value;
}

// required float m03 = 4;
inline bool Matrix4::has_m03() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Matrix4::set_has_m03() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Matrix4::clear_has_m03() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Matrix4::clear_m03() {
  m03_ = 0;
  clear_has_m03();
}
inline float Matrix4::m03() const {
  return m03_;
}
inline void Matrix4::set_m03(float value) {
  set_has_m03();
  m03_ = value;
}

// required float m10 = 5;
inline bool Matrix4::has_m10() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Matrix4::set_has_m10() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Matrix4::clear_has_m10() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Matrix4::clear_m10() {
  m10_ = 0;
  clear_has_m10();
}
inline float Matrix4::m10() const {
  return m10_;
}
inline void Matrix4::set_m10(float value) {
  set_has_m10();
  m10_ = value;
}

// required float m11 = 6;
inline bool Matrix4::has_m11() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Matrix4::set_has_m11() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Matrix4::clear_has_m11() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Matrix4::clear_m11() {
  m11_ = 0;
  clear_has_m11();
}
inline float Matrix4::m11() const {
  return m11_;
}
inline void Matrix4::set_m11(float value) {
  set_has_m11();
  m11_ = value;
}

// required float m12 = 7;
inline bool Matrix4::has_m12() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Matrix4::set_has_m12() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Matrix4::clear_has_m12() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Matrix4::clear_m12() {
  m12_ = 0;
  clear_has_m12();
}
inline float Matrix4::m12() const {
  return m12_;
}
inline void Matrix4::set_m12(float value) {
  set_has_m12();
  m12_ = value;
}

// required float m13 = 8;
inline bool Matrix4::has_m13() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Matrix4::set_has_m13() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Matrix4::clear_has_m13() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Matrix4::clear_m13() {
  m13_ = 0;
  clear_has_m13();
}
inline float Matrix4::m13() const {
  return m13_;
}
inline void Matrix4::set_m13(float value) {
  set_has_m13();
  m13_ = value;
}

// required float m20 = 9;
inline bool Matrix4::has_m20() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Matrix4::set_has_m20() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Matrix4::clear_has_m20() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Matrix4::clear_m20() {
  m20_ = 0;
  clear_has_m20();
}
inline float Matrix4::m20() const {
  return m20_;
}
inline void Matrix4::set_m20(float value) {
  set_has_m20();
  m20_ = value;
}

// required float m21 = 10;
inline bool Matrix4::has_m21() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Matrix4::set_has_m21() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Matrix4::clear_has_m21() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Matrix4::clear_m21() {
  m21_ = 0;
  clear_has_m21();
}
inline float Matrix4::m21() const {
  return m21_;
}
inline void Matrix4::set_m21(float value) {
  set_has_m21();
  m21_ = value;
}

// required float m22 = 11;
inline bool Matrix4::has_m22() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Matrix4::set_has_m22() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Matrix4::clear_has_m22() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Matrix4::clear_m22() {
  m22_ = 0;
  clear_has_m22();
}
inline float Matrix4::m22() const {
  return m22_;
}
inline void Matrix4::set_m22(float value) {
  set_has_m22();
  m22_ = value;
}

// required float m23 = 12;
inline bool Matrix4::has_m23() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Matrix4::set_has_m23() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Matrix4::clear_has_m23() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Matrix4::clear_m23() {
  m23_ = 0;
  clear_has_m23();
}
inline float Matrix4::m23() const {
  return m23_;
}
inline void Matrix4::set_m23(float value) {
  set_has_m23();
  m23_ = value;
}

// required float m30 = 13;
inline bool Matrix4::has_m30() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Matrix4::set_has_m30() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Matrix4::clear_has_m30() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Matrix4::clear_m30() {
  m30_ = 0;
  clear_has_m30();
}
inline float Matrix4::m30() const {
  return m30_;
}
inline void Matrix4::set_m30(float value) {
  set_has_m30();
  m30_ = value;
}

// required float m31 = 14;
inline bool Matrix4::has_m31() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Matrix4::set_has_m31() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Matrix4::clear_has_m31() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Matrix4::clear_m31() {
  m31_ = 0;
  clear_has_m31();
}
inline float Matrix4::m31() const {
  return m31_;
}
inline void Matrix4::set_m31(float value) {
  set_has_m31();
  m31_ = value;
}

// required float m32 = 15;
inline bool Matrix4::has_m32() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Matrix4::set_has_m32() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Matrix4::clear_has_m32() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Matrix4::clear_m32() {
  m32_ = 0;
  clear_has_m32();
}
inline float Matrix4::m32() const {
  return m32_;
}
inline void Matrix4::set_m32(float value) {
  set_has_m32();
  m32_ = value;
}

// required float m33 = 16;
inline bool Matrix4::has_m33() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Matrix4::set_has_m33() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Matrix4::clear_has_m33() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Matrix4::clear_m33() {
  m33_ = 0;
  clear_has_m33();
}
inline float Matrix4::m33() const {
  return m33_;
}
inline void Matrix4::set_m33(float value) {
  set_has_m33();
  m33_ = value;
}

// -------------------------------------------------------------------

// Sampler

// optional .NMLPackage.Sampler.Filter filter = 1;
inline bool Sampler::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sampler::set_has_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sampler::clear_has_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sampler::clear_filter() {
  filter_ = 1;
  clear_has_filter();
}
inline ::NMLPackage::Sampler_Filter Sampler::filter() const {
  return static_cast< ::NMLPackage::Sampler_Filter >(filter_);
}
inline void Sampler::set_filter(::NMLPackage::Sampler_Filter value) {
  GOOGLE_DCHECK(::NMLPackage::Sampler_Filter_IsValid(value));
  set_has_filter();
  filter_ = value;
}

// optional .NMLPackage.Sampler.WrapMode wrap_s = 2;
inline bool Sampler::has_wrap_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sampler::set_has_wrap_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sampler::clear_has_wrap_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sampler::clear_wrap_s() {
  wrap_s_ = 1;
  clear_has_wrap_s();
}
inline ::NMLPackage::Sampler_WrapMode Sampler::wrap_s() const {
  return static_cast< ::NMLPackage::Sampler_WrapMode >(wrap_s_);
}
inline void Sampler::set_wrap_s(::NMLPackage::Sampler_WrapMode value) {
  GOOGLE_DCHECK(::NMLPackage::Sampler_WrapMode_IsValid(value));
  set_has_wrap_s();
  wrap_s_ = value;
}

// optional .NMLPackage.Sampler.WrapMode wrap_t = 3;
inline bool Sampler::has_wrap_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sampler::set_has_wrap_t() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sampler::clear_has_wrap_t() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sampler::clear_wrap_t() {
  wrap_t_ = 1;
  clear_has_wrap_t();
}
inline ::NMLPackage::Sampler_WrapMode Sampler::wrap_t() const {
  return static_cast< ::NMLPackage::Sampler_WrapMode >(wrap_t_);
}
inline void Sampler::set_wrap_t(::NMLPackage::Sampler_WrapMode value) {
  GOOGLE_DCHECK(::NMLPackage::Sampler_WrapMode_IsValid(value));
  set_has_wrap_t();
  wrap_t_ = value;
}

// -------------------------------------------------------------------

// Texture

// required string id = 1;
inline bool Texture::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Texture::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Texture::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Texture::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Texture::id() const {
  return *id_;
}
inline void Texture::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Texture::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Texture::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Texture::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Texture::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .NMLPackage.Texture.Format format = 2;
inline bool Texture::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Texture::set_has_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Texture::clear_has_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Texture::clear_format() {
  format_ = -2;
  clear_has_format();
}
inline ::NMLPackage::Texture_Format Texture::format() const {
  return static_cast< ::NMLPackage::Texture_Format >(format_);
}
inline void Texture::set_format(::NMLPackage::Texture_Format value) {
  GOOGLE_DCHECK(::NMLPackage::Texture_Format_IsValid(value));
  set_has_format();
  format_ = value;
}

// required int32 width = 3;
inline bool Texture::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Texture::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Texture::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Texture::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Texture::width() const {
  return width_;
}
inline void Texture::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required int32 height = 4;
inline bool Texture::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Texture::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Texture::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Texture::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Texture::height() const {
  return height_;
}
inline void Texture::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// required .NMLPackage.Sampler sampler = 5;
inline bool Texture::has_sampler() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Texture::set_has_sampler() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Texture::clear_has_sampler() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Texture::clear_sampler() {
  if (sampler_ != NULL) sampler_->::NMLPackage::Sampler::Clear();
  clear_has_sampler();
}
inline const ::NMLPackage::Sampler& Texture::sampler() const {
  return sampler_ != NULL ? *sampler_ : *default_instance_->sampler_;
}
inline ::NMLPackage::Sampler* Texture::mutable_sampler() {
  set_has_sampler();
  if (sampler_ == NULL) sampler_ = new ::NMLPackage::Sampler;
  return sampler_;
}
inline ::NMLPackage::Sampler* Texture::release_sampler() {
  clear_has_sampler();
  ::NMLPackage::Sampler* temp = sampler_;
  sampler_ = NULL;
  return temp;
}

// repeated bytes mipmaps = 6;
inline int Texture::mipmaps_size() const {
  return mipmaps_.size();
}
inline void Texture::clear_mipmaps() {
  mipmaps_.Clear();
}
inline const ::std::string& Texture::mipmaps(int index) const {
  return mipmaps_.Get(index);
}
inline ::std::string* Texture::mutable_mipmaps(int index) {
  return mipmaps_.Mutable(index);
}
inline void Texture::set_mipmaps(int index, const ::std::string& value) {
  mipmaps_.Mutable(index)->assign(value);
}
inline void Texture::set_mipmaps(int index, const char* value) {
  mipmaps_.Mutable(index)->assign(value);
}
inline void Texture::set_mipmaps(int index, const void* value, size_t size) {
  mipmaps_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Texture::add_mipmaps() {
  return mipmaps_.Add();
}
inline void Texture::add_mipmaps(const ::std::string& value) {
  mipmaps_.Add()->assign(value);
}
inline void Texture::add_mipmaps(const char* value) {
  mipmaps_.Add()->assign(value);
}
inline void Texture::add_mipmaps(const void* value, size_t size) {
  mipmaps_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Texture::mipmaps() const {
  return mipmaps_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Texture::mutable_mipmaps() {
  return &mipmaps_;
}

// -------------------------------------------------------------------

// ColorOrTexture

// required .NMLPackage.ColorOrTexture.Type type = 1;
inline bool ColorOrTexture::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColorOrTexture::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColorOrTexture::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColorOrTexture::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::NMLPackage::ColorOrTexture_Type ColorOrTexture::type() const {
  return static_cast< ::NMLPackage::ColorOrTexture_Type >(type_);
}
inline void ColorOrTexture::set_type(::NMLPackage::ColorOrTexture_Type value) {
  GOOGLE_DCHECK(::NMLPackage::ColorOrTexture_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .NMLPackage.ColorRGBA color = 2;
inline bool ColorOrTexture::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColorOrTexture::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColorOrTexture::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColorOrTexture::clear_color() {
  if (color_ != NULL) color_->::NMLPackage::ColorRGBA::Clear();
  clear_has_color();
}
inline const ::NMLPackage::ColorRGBA& ColorOrTexture::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::NMLPackage::ColorRGBA* ColorOrTexture::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::NMLPackage::ColorRGBA;
  return color_;
}
inline ::NMLPackage::ColorRGBA* ColorOrTexture::release_color() {
  clear_has_color();
  ::NMLPackage::ColorRGBA* temp = color_;
  color_ = NULL;
  return temp;
}

// optional string texture_id = 3;
inline bool ColorOrTexture::has_texture_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColorOrTexture::set_has_texture_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColorOrTexture::clear_has_texture_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColorOrTexture::clear_texture_id() {
  if (texture_id_ != &::google::protobuf::internal::kEmptyString) {
    texture_id_->clear();
  }
  clear_has_texture_id();
}
inline const ::std::string& ColorOrTexture::texture_id() const {
  return *texture_id_;
}
inline void ColorOrTexture::set_texture_id(const ::std::string& value) {
  set_has_texture_id();
  if (texture_id_ == &::google::protobuf::internal::kEmptyString) {
    texture_id_ = new ::std::string;
  }
  texture_id_->assign(value);
}
inline void ColorOrTexture::set_texture_id(const char* value) {
  set_has_texture_id();
  if (texture_id_ == &::google::protobuf::internal::kEmptyString) {
    texture_id_ = new ::std::string;
  }
  texture_id_->assign(value);
}
inline void ColorOrTexture::set_texture_id(const char* value, size_t size) {
  set_has_texture_id();
  if (texture_id_ == &::google::protobuf::internal::kEmptyString) {
    texture_id_ = new ::std::string;
  }
  texture_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColorOrTexture::mutable_texture_id() {
  set_has_texture_id();
  if (texture_id_ == &::google::protobuf::internal::kEmptyString) {
    texture_id_ = new ::std::string;
  }
  return texture_id_;
}
inline ::std::string* ColorOrTexture::release_texture_id() {
  clear_has_texture_id();
  if (texture_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = texture_id_;
    texture_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Material

// required string id = 1;
inline bool Material::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Material::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Material::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Material::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Material::id() const {
  return *id_;
}
inline void Material::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Material::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Material::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Material::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Material::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .NMLPackage.Material.Type type = 2;
inline bool Material::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Material::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Material::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Material::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::NMLPackage::Material_Type Material::type() const {
  return static_cast< ::NMLPackage::Material_Type >(type_);
}
inline void Material::set_type(::NMLPackage::Material_Type value) {
  GOOGLE_DCHECK(::NMLPackage::Material_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .NMLPackage.Material.Culling culling = 3;
inline bool Material::has_culling() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Material::set_has_culling() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Material::clear_has_culling() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Material::clear_culling() {
  culling_ = 1;
  clear_has_culling();
}
inline ::NMLPackage::Material_Culling Material::culling() const {
  return static_cast< ::NMLPackage::Material_Culling >(culling_);
}
inline void Material::set_culling(::NMLPackage::Material_Culling value) {
  GOOGLE_DCHECK(::NMLPackage::Material_Culling_IsValid(value));
  set_has_culling();
  culling_ = value;
}

// optional .NMLPackage.ColorOrTexture emission = 4;
inline bool Material::has_emission() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Material::set_has_emission() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Material::clear_has_emission() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Material::clear_emission() {
  if (emission_ != NULL) emission_->::NMLPackage::ColorOrTexture::Clear();
  clear_has_emission();
}
inline const ::NMLPackage::ColorOrTexture& Material::emission() const {
  return emission_ != NULL ? *emission_ : *default_instance_->emission_;
}
inline ::NMLPackage::ColorOrTexture* Material::mutable_emission() {
  set_has_emission();
  if (emission_ == NULL) emission_ = new ::NMLPackage::ColorOrTexture;
  return emission_;
}
inline ::NMLPackage::ColorOrTexture* Material::release_emission() {
  clear_has_emission();
  ::NMLPackage::ColorOrTexture* temp = emission_;
  emission_ = NULL;
  return temp;
}

// optional .NMLPackage.ColorOrTexture ambient = 5;
inline bool Material::has_ambient() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Material::set_has_ambient() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Material::clear_has_ambient() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Material::clear_ambient() {
  if (ambient_ != NULL) ambient_->::NMLPackage::ColorOrTexture::Clear();
  clear_has_ambient();
}
inline const ::NMLPackage::ColorOrTexture& Material::ambient() const {
  return ambient_ != NULL ? *ambient_ : *default_instance_->ambient_;
}
inline ::NMLPackage::ColorOrTexture* Material::mutable_ambient() {
  set_has_ambient();
  if (ambient_ == NULL) ambient_ = new ::NMLPackage::ColorOrTexture;
  return ambient_;
}
inline ::NMLPackage::ColorOrTexture* Material::release_ambient() {
  clear_has_ambient();
  ::NMLPackage::ColorOrTexture* temp = ambient_;
  ambient_ = NULL;
  return temp;
}

// optional .NMLPackage.ColorOrTexture diffuse = 6;
inline bool Material::has_diffuse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Material::set_has_diffuse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Material::clear_has_diffuse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Material::clear_diffuse() {
  if (diffuse_ != NULL) diffuse_->::NMLPackage::ColorOrTexture::Clear();
  clear_has_diffuse();
}
inline const ::NMLPackage::ColorOrTexture& Material::diffuse() const {
  return diffuse_ != NULL ? *diffuse_ : *default_instance_->diffuse_;
}
inline ::NMLPackage::ColorOrTexture* Material::mutable_diffuse() {
  set_has_diffuse();
  if (diffuse_ == NULL) diffuse_ = new ::NMLPackage::ColorOrTexture;
  return diffuse_;
}
inline ::NMLPackage::ColorOrTexture* Material::release_diffuse() {
  clear_has_diffuse();
  ::NMLPackage::ColorOrTexture* temp = diffuse_;
  diffuse_ = NULL;
  return temp;
}

// optional bool translucent = 7;
inline bool Material::has_translucent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Material::set_has_translucent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Material::clear_has_translucent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Material::clear_translucent() {
  translucent_ = false;
  clear_has_translucent();
}
inline bool Material::translucent() const {
  return translucent_;
}
inline void Material::set_translucent(bool value) {
  set_has_translucent();
  translucent_ = value;
}

// -------------------------------------------------------------------

// Submesh

// required .NMLPackage.Submesh.Type type = 1;
inline bool Submesh::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Submesh::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Submesh::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Submesh::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::NMLPackage::Submesh_Type Submesh::type() const {
  return static_cast< ::NMLPackage::Submesh_Type >(type_);
}
inline void Submesh::set_type(::NMLPackage::Submesh_Type value) {
  GOOGLE_DCHECK(::NMLPackage::Submesh_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string material_id = 2;
inline bool Submesh::has_material_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Submesh::set_has_material_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Submesh::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Submesh::clear_material_id() {
  if (material_id_ != &::google::protobuf::internal::kEmptyString) {
    material_id_->clear();
  }
  clear_has_material_id();
}
inline const ::std::string& Submesh::material_id() const {
  return *material_id_;
}
inline void Submesh::set_material_id(const ::std::string& value) {
  set_has_material_id();
  if (material_id_ == &::google::protobuf::internal::kEmptyString) {
    material_id_ = new ::std::string;
  }
  material_id_->assign(value);
}
inline void Submesh::set_material_id(const char* value) {
  set_has_material_id();
  if (material_id_ == &::google::protobuf::internal::kEmptyString) {
    material_id_ = new ::std::string;
  }
  material_id_->assign(value);
}
inline void Submesh::set_material_id(const char* value, size_t size) {
  set_has_material_id();
  if (material_id_ == &::google::protobuf::internal::kEmptyString) {
    material_id_ = new ::std::string;
  }
  material_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Submesh::mutable_material_id() {
  set_has_material_id();
  if (material_id_ == &::google::protobuf::internal::kEmptyString) {
    material_id_ = new ::std::string;
  }
  return material_id_;
}
inline ::std::string* Submesh::release_material_id() {
  clear_has_material_id();
  if (material_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = material_id_;
    material_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 vertex_counts = 3;
inline int Submesh::vertex_counts_size() const {
  return vertex_counts_.size();
}
inline void Submesh::clear_vertex_counts() {
  vertex_counts_.Clear();
}
inline ::google::protobuf::int32 Submesh::vertex_counts(int index) const {
  return vertex_counts_.Get(index);
}
inline void Submesh::set_vertex_counts(int index, ::google::protobuf::int32 value) {
  vertex_counts_.Set(index, value);
}
inline void Submesh::add_vertex_counts(::google::protobuf::int32 value) {
  vertex_counts_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Submesh::vertex_counts() const {
  return vertex_counts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Submesh::mutable_vertex_counts() {
  return &vertex_counts_;
}

// required bytes positions = 4;
inline bool Submesh::has_positions() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Submesh::set_has_positions() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Submesh::clear_has_positions() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Submesh::clear_positions() {
  if (positions_ != &::google::protobuf::internal::kEmptyString) {
    positions_->clear();
  }
  clear_has_positions();
}
inline const ::std::string& Submesh::positions() const {
  return *positions_;
}
inline void Submesh::set_positions(const ::std::string& value) {
  set_has_positions();
  if (positions_ == &::google::protobuf::internal::kEmptyString) {
    positions_ = new ::std::string;
  }
  positions_->assign(value);
}
inline void Submesh::set_positions(const char* value) {
  set_has_positions();
  if (positions_ == &::google::protobuf::internal::kEmptyString) {
    positions_ = new ::std::string;
  }
  positions_->assign(value);
}
inline void Submesh::set_positions(const void* value, size_t size) {
  set_has_positions();
  if (positions_ == &::google::protobuf::internal::kEmptyString) {
    positions_ = new ::std::string;
  }
  positions_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Submesh::mutable_positions() {
  set_has_positions();
  if (positions_ == &::google::protobuf::internal::kEmptyString) {
    positions_ = new ::std::string;
  }
  return positions_;
}
inline ::std::string* Submesh::release_positions() {
  clear_has_positions();
  if (positions_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = positions_;
    positions_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes normals = 5;
inline bool Submesh::has_normals() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Submesh::set_has_normals() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Submesh::clear_has_normals() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Submesh::clear_normals() {
  if (normals_ != &::google::protobuf::internal::kEmptyString) {
    normals_->clear();
  }
  clear_has_normals();
}
inline const ::std::string& Submesh::normals() const {
  return *normals_;
}
inline void Submesh::set_normals(const ::std::string& value) {
  set_has_normals();
  if (normals_ == &::google::protobuf::internal::kEmptyString) {
    normals_ = new ::std::string;
  }
  normals_->assign(value);
}
inline void Submesh::set_normals(const char* value) {
  set_has_normals();
  if (normals_ == &::google::protobuf::internal::kEmptyString) {
    normals_ = new ::std::string;
  }
  normals_->assign(value);
}
inline void Submesh::set_normals(const void* value, size_t size) {
  set_has_normals();
  if (normals_ == &::google::protobuf::internal::kEmptyString) {
    normals_ = new ::std::string;
  }
  normals_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Submesh::mutable_normals() {
  set_has_normals();
  if (normals_ == &::google::protobuf::internal::kEmptyString) {
    normals_ = new ::std::string;
  }
  return normals_;
}
inline ::std::string* Submesh::release_normals() {
  clear_has_normals();
  if (normals_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = normals_;
    normals_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes uvs = 6;
inline bool Submesh::has_uvs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Submesh::set_has_uvs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Submesh::clear_has_uvs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Submesh::clear_uvs() {
  if (uvs_ != &::google::protobuf::internal::kEmptyString) {
    uvs_->clear();
  }
  clear_has_uvs();
}
inline const ::std::string& Submesh::uvs() const {
  return *uvs_;
}
inline void Submesh::set_uvs(const ::std::string& value) {
  set_has_uvs();
  if (uvs_ == &::google::protobuf::internal::kEmptyString) {
    uvs_ = new ::std::string;
  }
  uvs_->assign(value);
}
inline void Submesh::set_uvs(const char* value) {
  set_has_uvs();
  if (uvs_ == &::google::protobuf::internal::kEmptyString) {
    uvs_ = new ::std::string;
  }
  uvs_->assign(value);
}
inline void Submesh::set_uvs(const void* value, size_t size) {
  set_has_uvs();
  if (uvs_ == &::google::protobuf::internal::kEmptyString) {
    uvs_ = new ::std::string;
  }
  uvs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Submesh::mutable_uvs() {
  set_has_uvs();
  if (uvs_ == &::google::protobuf::internal::kEmptyString) {
    uvs_ = new ::std::string;
  }
  return uvs_;
}
inline ::std::string* Submesh::release_uvs() {
  clear_has_uvs();
  if (uvs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uvs_;
    uvs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes colors = 7;
inline bool Submesh::has_colors() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Submesh::set_has_colors() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Submesh::clear_has_colors() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Submesh::clear_colors() {
  if (colors_ != &::google::protobuf::internal::kEmptyString) {
    colors_->clear();
  }
  clear_has_colors();
}
inline const ::std::string& Submesh::colors() const {
  return *colors_;
}
inline void Submesh::set_colors(const ::std::string& value) {
  set_has_colors();
  if (colors_ == &::google::protobuf::internal::kEmptyString) {
    colors_ = new ::std::string;
  }
  colors_->assign(value);
}
inline void Submesh::set_colors(const char* value) {
  set_has_colors();
  if (colors_ == &::google::protobuf::internal::kEmptyString) {
    colors_ = new ::std::string;
  }
  colors_->assign(value);
}
inline void Submesh::set_colors(const void* value, size_t size) {
  set_has_colors();
  if (colors_ == &::google::protobuf::internal::kEmptyString) {
    colors_ = new ::std::string;
  }
  colors_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Submesh::mutable_colors() {
  set_has_colors();
  if (colors_ == &::google::protobuf::internal::kEmptyString) {
    colors_ = new ::std::string;
  }
  return colors_;
}
inline ::std::string* Submesh::release_colors() {
  clear_has_colors();
  if (colors_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = colors_;
    colors_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int64 vertex_ids = 8;
inline int Submesh::vertex_ids_size() const {
  return vertex_ids_.size();
}
inline void Submesh::clear_vertex_ids() {
  vertex_ids_.Clear();
}
inline ::google::protobuf::int64 Submesh::vertex_ids(int index) const {
  return vertex_ids_.Get(index);
}
inline void Submesh::set_vertex_ids(int index, ::google::protobuf::int64 value) {
  vertex_ids_.Set(index, value);
}
inline void Submesh::add_vertex_ids(::google::protobuf::int64 value) {
  vertex_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Submesh::vertex_ids() const {
  return vertex_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Submesh::mutable_vertex_ids() {
  return &vertex_ids_;
}

// -------------------------------------------------------------------

// Mesh

// required string id = 1;
inline bool Mesh::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mesh::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mesh::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mesh::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Mesh::id() const {
  return *id_;
}
inline void Mesh::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Mesh::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Mesh::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mesh::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Mesh::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .NMLPackage.Bounds3 bounds = 2;
inline bool Mesh::has_bounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mesh::set_has_bounds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mesh::clear_has_bounds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mesh::clear_bounds() {
  if (bounds_ != NULL) bounds_->::NMLPackage::Bounds3::Clear();
  clear_has_bounds();
}
inline const ::NMLPackage::Bounds3& Mesh::bounds() const {
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
}
inline ::NMLPackage::Bounds3* Mesh::mutable_bounds() {
  set_has_bounds();
  if (bounds_ == NULL) bounds_ = new ::NMLPackage::Bounds3;
  return bounds_;
}
inline ::NMLPackage::Bounds3* Mesh::release_bounds() {
  clear_has_bounds();
  ::NMLPackage::Bounds3* temp = bounds_;
  bounds_ = NULL;
  return temp;
}

// repeated .NMLPackage.Submesh submeshes = 3;
inline int Mesh::submeshes_size() const {
  return submeshes_.size();
}
inline void Mesh::clear_submeshes() {
  submeshes_.Clear();
}
inline const ::NMLPackage::Submesh& Mesh::submeshes(int index) const {
  return submeshes_.Get(index);
}
inline ::NMLPackage::Submesh* Mesh::mutable_submeshes(int index) {
  return submeshes_.Mutable(index);
}
inline ::NMLPackage::Submesh* Mesh::add_submeshes() {
  return submeshes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::Submesh >&
Mesh::submeshes() const {
  return submeshes_;
}
inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::Submesh >*
Mesh::mutable_submeshes() {
  return &submeshes_;
}

// -------------------------------------------------------------------

// MeshInstance

// required string mesh_id = 1;
inline bool MeshInstance::has_mesh_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeshInstance::set_has_mesh_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeshInstance::clear_has_mesh_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeshInstance::clear_mesh_id() {
  if (mesh_id_ != &::google::protobuf::internal::kEmptyString) {
    mesh_id_->clear();
  }
  clear_has_mesh_id();
}
inline const ::std::string& MeshInstance::mesh_id() const {
  return *mesh_id_;
}
inline void MeshInstance::set_mesh_id(const ::std::string& value) {
  set_has_mesh_id();
  if (mesh_id_ == &::google::protobuf::internal::kEmptyString) {
    mesh_id_ = new ::std::string;
  }
  mesh_id_->assign(value);
}
inline void MeshInstance::set_mesh_id(const char* value) {
  set_has_mesh_id();
  if (mesh_id_ == &::google::protobuf::internal::kEmptyString) {
    mesh_id_ = new ::std::string;
  }
  mesh_id_->assign(value);
}
inline void MeshInstance::set_mesh_id(const char* value, size_t size) {
  set_has_mesh_id();
  if (mesh_id_ == &::google::protobuf::internal::kEmptyString) {
    mesh_id_ = new ::std::string;
  }
  mesh_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MeshInstance::mutable_mesh_id() {
  set_has_mesh_id();
  if (mesh_id_ == &::google::protobuf::internal::kEmptyString) {
    mesh_id_ = new ::std::string;
  }
  return mesh_id_;
}
inline ::std::string* MeshInstance::release_mesh_id() {
  clear_has_mesh_id();
  if (mesh_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mesh_id_;
    mesh_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .NMLPackage.Material materials = 2;
inline int MeshInstance::materials_size() const {
  return materials_.size();
}
inline void MeshInstance::clear_materials() {
  materials_.Clear();
}
inline const ::NMLPackage::Material& MeshInstance::materials(int index) const {
  return materials_.Get(index);
}
inline ::NMLPackage::Material* MeshInstance::mutable_materials(int index) {
  return materials_.Mutable(index);
}
inline ::NMLPackage::Material* MeshInstance::add_materials() {
  return materials_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::Material >&
MeshInstance::materials() const {
  return materials_;
}
inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::Material >*
MeshInstance::mutable_materials() {
  return &materials_;
}

// optional .NMLPackage.Matrix4 transform = 3;
inline bool MeshInstance::has_transform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MeshInstance::set_has_transform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MeshInstance::clear_has_transform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MeshInstance::clear_transform() {
  if (transform_ != NULL) transform_->::NMLPackage::Matrix4::Clear();
  clear_has_transform();
}
inline const ::NMLPackage::Matrix4& MeshInstance::transform() const {
  return transform_ != NULL ? *transform_ : *default_instance_->transform_;
}
inline ::NMLPackage::Matrix4* MeshInstance::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) transform_ = new ::NMLPackage::Matrix4;
  return transform_;
}
inline ::NMLPackage::Matrix4* MeshInstance::release_transform() {
  clear_has_transform();
  ::NMLPackage::Matrix4* temp = transform_;
  transform_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SubmeshOp

// required int32 submesh_idx = 1;
inline bool SubmeshOp::has_submesh_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmeshOp::set_has_submesh_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmeshOp::clear_has_submesh_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmeshOp::clear_submesh_idx() {
  submesh_idx_ = 0;
  clear_has_submesh_idx();
}
inline ::google::protobuf::int32 SubmeshOp::submesh_idx() const {
  return submesh_idx_;
}
inline void SubmeshOp::set_submesh_idx(::google::protobuf::int32 value) {
  set_has_submesh_idx();
  submesh_idx_ = value;
}

// required int32 offset = 2;
inline bool SubmeshOp::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmeshOp::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmeshOp::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmeshOp::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 SubmeshOp::offset() const {
  return offset_;
}
inline void SubmeshOp::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// required int32 count = 3;
inline bool SubmeshOp::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubmeshOp::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubmeshOp::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubmeshOp::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 SubmeshOp::count() const {
  return count_;
}
inline void SubmeshOp::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// required float tex_u_scale = 4;
inline bool SubmeshOp::has_tex_u_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubmeshOp::set_has_tex_u_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubmeshOp::clear_has_tex_u_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubmeshOp::clear_tex_u_scale() {
  tex_u_scale_ = 0;
  clear_has_tex_u_scale();
}
inline float SubmeshOp::tex_u_scale() const {
  return tex_u_scale_;
}
inline void SubmeshOp::set_tex_u_scale(float value) {
  set_has_tex_u_scale();
  tex_u_scale_ = value;
}

// required float tex_v_scale = 5;
inline bool SubmeshOp::has_tex_v_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubmeshOp::set_has_tex_v_scale() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubmeshOp::clear_has_tex_v_scale() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubmeshOp::clear_tex_v_scale() {
  tex_v_scale_ = 0;
  clear_has_tex_v_scale();
}
inline float SubmeshOp::tex_v_scale() const {
  return tex_v_scale_;
}
inline void SubmeshOp::set_tex_v_scale(float value) {
  set_has_tex_v_scale();
  tex_v_scale_ = value;
}

// required float tex_u_trans = 6;
inline bool SubmeshOp::has_tex_u_trans() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubmeshOp::set_has_tex_u_trans() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubmeshOp::clear_has_tex_u_trans() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubmeshOp::clear_tex_u_trans() {
  tex_u_trans_ = 0;
  clear_has_tex_u_trans();
}
inline float SubmeshOp::tex_u_trans() const {
  return tex_u_trans_;
}
inline void SubmeshOp::set_tex_u_trans(float value) {
  set_has_tex_u_trans();
  tex_u_trans_ = value;
}

// required float tex_v_trans = 7;
inline bool SubmeshOp::has_tex_v_trans() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubmeshOp::set_has_tex_v_trans() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubmeshOp::clear_has_tex_v_trans() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubmeshOp::clear_tex_v_trans() {
  tex_v_trans_ = 0;
  clear_has_tex_v_trans();
}
inline float SubmeshOp::tex_v_trans() const {
  return tex_v_trans_;
}
inline void SubmeshOp::set_tex_v_trans(float value) {
  set_has_tex_v_trans();
  tex_v_trans_ = value;
}

// -------------------------------------------------------------------

// SubmeshOpList

// required .NMLPackage.Submesh.Type type = 1;
inline bool SubmeshOpList::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmeshOpList::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmeshOpList::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmeshOpList::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::NMLPackage::Submesh_Type SubmeshOpList::type() const {
  return static_cast< ::NMLPackage::Submesh_Type >(type_);
}
inline void SubmeshOpList::set_type(::NMLPackage::Submesh_Type value) {
  GOOGLE_DCHECK(::NMLPackage::Submesh_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string material_id = 2;
inline bool SubmeshOpList::has_material_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmeshOpList::set_has_material_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmeshOpList::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmeshOpList::clear_material_id() {
  if (material_id_ != &::google::protobuf::internal::kEmptyString) {
    material_id_->clear();
  }
  clear_has_material_id();
}
inline const ::std::string& SubmeshOpList::material_id() const {
  return *material_id_;
}
inline void SubmeshOpList::set_material_id(const ::std::string& value) {
  set_has_material_id();
  if (material_id_ == &::google::protobuf::internal::kEmptyString) {
    material_id_ = new ::std::string;
  }
  material_id_->assign(value);
}
inline void SubmeshOpList::set_material_id(const char* value) {
  set_has_material_id();
  if (material_id_ == &::google::protobuf::internal::kEmptyString) {
    material_id_ = new ::std::string;
  }
  material_id_->assign(value);
}
inline void SubmeshOpList::set_material_id(const char* value, size_t size) {
  set_has_material_id();
  if (material_id_ == &::google::protobuf::internal::kEmptyString) {
    material_id_ = new ::std::string;
  }
  material_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubmeshOpList::mutable_material_id() {
  set_has_material_id();
  if (material_id_ == &::google::protobuf::internal::kEmptyString) {
    material_id_ = new ::std::string;
  }
  return material_id_;
}
inline ::std::string* SubmeshOpList::release_material_id() {
  clear_has_material_id();
  if (material_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = material_id_;
    material_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .NMLPackage.SubmeshOp submesh_ops = 3;
inline int SubmeshOpList::submesh_ops_size() const {
  return submesh_ops_.size();
}
inline void SubmeshOpList::clear_submesh_ops() {
  submesh_ops_.Clear();
}
inline const ::NMLPackage::SubmeshOp& SubmeshOpList::submesh_ops(int index) const {
  return submesh_ops_.Get(index);
}
inline ::NMLPackage::SubmeshOp* SubmeshOpList::mutable_submesh_ops(int index) {
  return submesh_ops_.Mutable(index);
}
inline ::NMLPackage::SubmeshOp* SubmeshOpList::add_submesh_ops() {
  return submesh_ops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::SubmeshOp >&
SubmeshOpList::submesh_ops() const {
  return submesh_ops_;
}
inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::SubmeshOp >*
SubmeshOpList::mutable_submesh_ops() {
  return &submesh_ops_;
}

// -------------------------------------------------------------------

// MeshOp

// required string id = 1;
inline bool MeshOp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeshOp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeshOp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeshOp::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& MeshOp::id() const {
  return *id_;
}
inline void MeshOp::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MeshOp::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MeshOp::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MeshOp::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* MeshOp::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .NMLPackage.Bounds3 bounds = 2;
inline bool MeshOp::has_bounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MeshOp::set_has_bounds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MeshOp::clear_has_bounds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MeshOp::clear_bounds() {
  if (bounds_ != NULL) bounds_->::NMLPackage::Bounds3::Clear();
  clear_has_bounds();
}
inline const ::NMLPackage::Bounds3& MeshOp::bounds() const {
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
}
inline ::NMLPackage::Bounds3* MeshOp::mutable_bounds() {
  set_has_bounds();
  if (bounds_ == NULL) bounds_ = new ::NMLPackage::Bounds3;
  return bounds_;
}
inline ::NMLPackage::Bounds3* MeshOp::release_bounds() {
  clear_has_bounds();
  ::NMLPackage::Bounds3* temp = bounds_;
  bounds_ = NULL;
  return temp;
}

// repeated .NMLPackage.SubmeshOpList submesh_op_lists = 3;
inline int MeshOp::submesh_op_lists_size() const {
  return submesh_op_lists_.size();
}
inline void MeshOp::clear_submesh_op_lists() {
  submesh_op_lists_.Clear();
}
inline const ::NMLPackage::SubmeshOpList& MeshOp::submesh_op_lists(int index) const {
  return submesh_op_lists_.Get(index);
}
inline ::NMLPackage::SubmeshOpList* MeshOp::mutable_submesh_op_lists(int index) {
  return submesh_op_lists_.Mutable(index);
}
inline ::NMLPackage::SubmeshOpList* MeshOp::add_submesh_op_lists() {
  return submesh_op_lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::SubmeshOpList >&
MeshOp::submesh_op_lists() const {
  return submesh_op_lists_;
}
inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::SubmeshOpList >*
MeshOp::mutable_submesh_op_lists() {
  return &submesh_op_lists_;
}

// -------------------------------------------------------------------

// Model

// required string id = 1;
inline bool Model::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Model::id() const {
  return *id_;
}
inline void Model::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Model::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Model::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Model::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .NMLPackage.MeshInstance mesh_instances = 2;
inline int Model::mesh_instances_size() const {
  return mesh_instances_.size();
}
inline void Model::clear_mesh_instances() {
  mesh_instances_.Clear();
}
inline const ::NMLPackage::MeshInstance& Model::mesh_instances(int index) const {
  return mesh_instances_.Get(index);
}
inline ::NMLPackage::MeshInstance* Model::mutable_mesh_instances(int index) {
  return mesh_instances_.Mutable(index);
}
inline ::NMLPackage::MeshInstance* Model::add_mesh_instances() {
  return mesh_instances_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::MeshInstance >&
Model::mesh_instances() const {
  return mesh_instances_;
}
inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::MeshInstance >*
Model::mutable_mesh_instances() {
  return &mesh_instances_;
}

// repeated .NMLPackage.Mesh meshes = 3;
inline int Model::meshes_size() const {
  return meshes_.size();
}
inline void Model::clear_meshes() {
  meshes_.Clear();
}
inline const ::NMLPackage::Mesh& Model::meshes(int index) const {
  return meshes_.Get(index);
}
inline ::NMLPackage::Mesh* Model::mutable_meshes(int index) {
  return meshes_.Mutable(index);
}
inline ::NMLPackage::Mesh* Model::add_meshes() {
  return meshes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::Mesh >&
Model::meshes() const {
  return meshes_;
}
inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::Mesh >*
Model::mutable_meshes() {
  return &meshes_;
}

// repeated .NMLPackage.Texture textures = 4;
inline int Model::textures_size() const {
  return textures_.size();
}
inline void Model::clear_textures() {
  textures_.Clear();
}
inline const ::NMLPackage::Texture& Model::textures(int index) const {
  return textures_.Get(index);
}
inline ::NMLPackage::Texture* Model::mutable_textures(int index) {
  return textures_.Mutable(index);
}
inline ::NMLPackage::Texture* Model::add_textures() {
  return textures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::Texture >&
Model::textures() const {
  return textures_;
}
inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::Texture >*
Model::mutable_textures() {
  return &textures_;
}

// required .NMLPackage.Bounds3 bounds = 5;
inline bool Model::has_bounds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Model::set_has_bounds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Model::clear_has_bounds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Model::clear_bounds() {
  if (bounds_ != NULL) bounds_->::NMLPackage::Bounds3::Clear();
  clear_has_bounds();
}
inline const ::NMLPackage::Bounds3& Model::bounds() const {
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
}
inline ::NMLPackage::Bounds3* Model::mutable_bounds() {
  set_has_bounds();
  if (bounds_ == NULL) bounds_ = new ::NMLPackage::Bounds3;
  return bounds_;
}
inline ::NMLPackage::Bounds3* Model::release_bounds() {
  clear_has_bounds();
  ::NMLPackage::Bounds3* temp = bounds_;
  bounds_ = NULL;
  return temp;
}

// required int32 mesh_footprint = 6;
inline bool Model::has_mesh_footprint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Model::set_has_mesh_footprint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Model::clear_has_mesh_footprint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Model::clear_mesh_footprint() {
  mesh_footprint_ = 0;
  clear_has_mesh_footprint();
}
inline ::google::protobuf::int32 Model::mesh_footprint() const {
  return mesh_footprint_;
}
inline void Model::set_mesh_footprint(::google::protobuf::int32 value) {
  set_has_mesh_footprint();
  mesh_footprint_ = value;
}

// required int32 texture_footprint = 7;
inline bool Model::has_texture_footprint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Model::set_has_texture_footprint() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Model::clear_has_texture_footprint() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Model::clear_texture_footprint() {
  texture_footprint_ = 0;
  clear_has_texture_footprint();
}
inline ::google::protobuf::int32 Model::texture_footprint() const {
  return texture_footprint_;
}
inline void Model::set_texture_footprint(::google::protobuf::int32 value) {
  set_has_texture_footprint();
  texture_footprint_ = value;
}

// -------------------------------------------------------------------

// ModelLODTreeNode

// required int32 id = 1;
inline bool ModelLODTreeNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelLODTreeNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelLODTreeNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelLODTreeNode::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ModelLODTreeNode::id() const {
  return id_;
}
inline void ModelLODTreeNode::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required .NMLPackage.Bounds3 bounds = 2;
inline bool ModelLODTreeNode::has_bounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelLODTreeNode::set_has_bounds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelLODTreeNode::clear_has_bounds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelLODTreeNode::clear_bounds() {
  if (bounds_ != NULL) bounds_->::NMLPackage::Bounds3::Clear();
  clear_has_bounds();
}
inline const ::NMLPackage::Bounds3& ModelLODTreeNode::bounds() const {
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
}
inline ::NMLPackage::Bounds3* ModelLODTreeNode::mutable_bounds() {
  set_has_bounds();
  if (bounds_ == NULL) bounds_ = new ::NMLPackage::Bounds3;
  return bounds_;
}
inline ::NMLPackage::Bounds3* ModelLODTreeNode::release_bounds() {
  clear_has_bounds();
  ::NMLPackage::Bounds3* temp = bounds_;
  bounds_ = NULL;
  return temp;
}

// required .NMLPackage.Model model = 3;
inline bool ModelLODTreeNode::has_model() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelLODTreeNode::set_has_model() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelLODTreeNode::clear_has_model() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelLODTreeNode::clear_model() {
  if (model_ != NULL) model_->::NMLPackage::Model::Clear();
  clear_has_model();
}
inline const ::NMLPackage::Model& ModelLODTreeNode::model() const {
  return model_ != NULL ? *model_ : *default_instance_->model_;
}
inline ::NMLPackage::Model* ModelLODTreeNode::mutable_model() {
  set_has_model();
  if (model_ == NULL) model_ = new ::NMLPackage::Model;
  return model_;
}
inline ::NMLPackage::Model* ModelLODTreeNode::release_model() {
  clear_has_model();
  ::NMLPackage::Model* temp = model_;
  model_ = NULL;
  return temp;
}

// repeated int32 children_ids = 4;
inline int ModelLODTreeNode::children_ids_size() const {
  return children_ids_.size();
}
inline void ModelLODTreeNode::clear_children_ids() {
  children_ids_.Clear();
}
inline ::google::protobuf::int32 ModelLODTreeNode::children_ids(int index) const {
  return children_ids_.Get(index);
}
inline void ModelLODTreeNode::set_children_ids(int index, ::google::protobuf::int32 value) {
  children_ids_.Set(index, value);
}
inline void ModelLODTreeNode::add_children_ids(::google::protobuf::int32 value) {
  children_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ModelLODTreeNode::children_ids() const {
  return children_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ModelLODTreeNode::mutable_children_ids() {
  return &children_ids_;
}

// -------------------------------------------------------------------

// ModelLODTree

// repeated .NMLPackage.ModelLODTreeNode nodes = 1;
inline int ModelLODTree::nodes_size() const {
  return nodes_.size();
}
inline void ModelLODTree::clear_nodes() {
  nodes_.Clear();
}
inline const ::NMLPackage::ModelLODTreeNode& ModelLODTree::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::NMLPackage::ModelLODTreeNode* ModelLODTree::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::NMLPackage::ModelLODTreeNode* ModelLODTree::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NMLPackage::ModelLODTreeNode >&
ModelLODTree::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::NMLPackage::ModelLODTreeNode >*
ModelLODTree::mutable_nodes() {
  return &nodes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace NMLPackage

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NMLPackage_2eproto__INCLUDED
